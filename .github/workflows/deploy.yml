name: Intelligent VoxPersona Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_restart_type:
        description: 'Force specific restart type'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - full
        - app-only
        - no-restart

env:
  DEPLOY_PATH: /home/voxpersona_user
  PROJECT_PATH: /home/voxpersona_user/VoxPersona
  APP_PATH: /home/voxpersona_user/app
  SSH_OPTIONS: "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Validate and sanitize user inputs
      id: validate_inputs
      env:
        USER_RESTART_TYPE: ${{ github.event.inputs.force_restart_type || 'auto' }}
      run: |
        echo "üîí Validating user inputs for security..."
        
        # Validate force_restart_type input using environment variable only
        case "$USER_RESTART_TYPE" in
          "auto"|"full"|"app-only"|"no-restart")
            echo "‚úÖ Valid restart type: $USER_RESTART_TYPE"
            echo "validated_restart_type=$USER_RESTART_TYPE" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "‚ùå Invalid restart type: $USER_RESTART_TYPE"
            echo "üîí Only allowed values: auto, full, app-only, no-restart"
            exit 1
            ;;
        esac
    
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python 3.10.11
      uses: actions/setup-python@v4
      with:
        python-version: "3.10.11"
    
    - name: Verify Python version compatibility
      run: |
        echo "üêç Checking Python version..."
        python --version
        python -c "import sys; assert sys.version_info[:2] == (3, 10), f'Expected Python 3.10, got {sys.version_info[:2]}'"
        echo "‚úÖ Python version verified: $(python --version)"
    
    - name: Setup SSH Key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
    
    - name: Add server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts
    
    - name: Test SSH Connection
      run: |
        echo "üîó Testing SSH connection..."
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "echo 'SSH connection successful'"
    
    - name: Get current deployment state
      id: deployment_state
      run: |
        echo "üìä Gathering deployment state information..."
        
        # Get current commit hash on server
        OLD_COMMIT=$(ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "cd ${{ env.PROJECT_PATH }} 2>/dev/null && git rev-parse HEAD 2>/dev/null || echo 'none'")
        echo "old_commit=$OLD_COMMIT" >> $GITHUB_OUTPUT
        echo "Current server commit: $OLD_COMMIT"
        
        # Get new commit hash (current)
        NEW_COMMIT="${{ github.sha }}"
        echo "new_commit=$NEW_COMMIT" >> $GITHUB_OUTPUT
        echo "New deployment commit: $NEW_COMMIT"
        
        # Record deployment start time
        DEPLOY_START=$(date +%s)
        echo "deploy_start=$DEPLOY_START" >> $GITHUB_OUTPUT
    
    - name: Sync repository to server
      run: |
        echo "üîÑ Syncing repository to server..."
        
        # Ensure project directory exists
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "mkdir -p ${{ env.DEPLOY_PATH }}"
        
        # Clone or update repository
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} '
          if [ ! -d "${{ env.PROJECT_PATH }}/.git" ]; then
            echo "üÜï Cloning repository for first time..."
            rm -rf ${{ env.PROJECT_PATH }}
            git clone https://github.com/${{ github.repository }}.git ${{ env.PROJECT_PATH }}
          else
            echo "üì• Updating existing repository..."
            cd ${{ env.PROJECT_PATH }}
            git fetch origin
            git reset --hard origin/main
          fi
        '
    
    - name: Analyze changes and determine deployment type
      id: deployment_analysis
      env:
        VALIDATED_RESTART_TYPE: ${{ steps.validate_inputs.outputs.validated_restart_type }}
        OLD_COMMIT: ${{ steps.deployment_state.outputs.old_commit }}
        NEW_COMMIT: ${{ steps.deployment_state.outputs.new_commit }}
      run: |
        echo "üîç Analyzing changes to determine deployment type..."
        
        # Get changed files between commits
        CHANGED_FILES=$(ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
          cd ${{ env.PROJECT_PATH }}
          if [ '$OLD_COMMIT' != 'none' ]; then
            git diff --name-only $OLD_COMMIT $NEW_COMMIT
          else
            echo 'Initial deployment - treating as FULL_RESTART'
            echo 'docker-compose.yml'
          fi
        ")
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Determine deployment type based on manual input or file analysis
        if [ "$VALIDATED_RESTART_TYPE" != "" ] && [ "$VALIDATED_RESTART_TYPE" != "auto" ]; then
          case "$VALIDATED_RESTART_TYPE" in
            "full") DEPLOY_TYPE="FULL_RESTART" ;;
            "app-only") DEPLOY_TYPE="APP_ONLY" ;;
            "no-restart") DEPLOY_TYPE="NO_RESTART" ;;
          esac
          echo "üéØ Manual deployment type: $DEPLOY_TYPE"
        else
          # Automatic detection logic
          if echo "$CHANGED_FILES" | grep -E "(docker-compose\.yml|Dockerfile|requirements\.txt|\.sql$|sql_scripts/)" > /dev/null || [ "$OLD_COMMIT" = "none" ]; then
            DEPLOY_TYPE="FULL_RESTART"
            echo "üîÑ Detected FULL_RESTART: Infrastructure files changed"
          elif echo "$CHANGED_FILES" | grep -E "(\.py$|src/|prompts/|prompts-by-scenario/)" > /dev/null; then
            DEPLOY_TYPE="APP_ONLY" 
            echo "üöÄ Detected APP_ONLY: Application files changed"
          elif echo "$CHANGED_FILES" | grep -E "(\.md$|\.txt$|\.rst$|README|CHANGELOG|\.gitignore$|DEPLOYMENT_GUIDE)" > /dev/null && ! echo "$CHANGED_FILES" | grep -v -E "(\.md$|\.txt$|\.rst$|README|CHANGELOG|\.gitignore$|DEPLOYMENT_GUIDE)" > /dev/null; then
            DEPLOY_TYPE="NO_RESTART"
            echo "üìù Detected NO_RESTART: Documentation only changes"
          else
            DEPLOY_TYPE="APP_ONLY"
            echo "üîÑ Default to APP_ONLY: Unknown file types detected"
          fi
        fi
        
        echo "deployment_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT
        echo "changed_files_count=$(echo '$CHANGED_FILES' | wc -l)" >> $GITHUB_OUTPUT
        
        echo "üìã Final deployment decision: $DEPLOY_TYPE"
    
    - name: Sync files to application directory
      run: |
        echo "üìÇ Syncing files to application directory..."
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
          # Ensure app directory exists
          mkdir -p ${{ env.APP_PATH }}
          
          # Sync files excluding .git directory
          rsync -av --delete --exclude='.git' --exclude='*.log' ${{ env.PROJECT_PATH }}/ ${{ env.APP_PATH }}/
          
          echo 'Files synchronized successfully'
        "
    
    - name: Execute deployment
      id: execute_deployment
      env:
        DEPLOY_TYPE: ${{ steps.deployment_analysis.outputs.deployment_type }}
      run: |
        echo "üöÄ Executing $DEPLOY_TYPE deployment..."
        
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
          cd ${{ env.APP_PATH }}
          
          case '$DEPLOY_TYPE' in
            'FULL_RESTART')
              echo 'üîÑ Executing FULL_RESTART: Rebuilding all containers...'
              docker-compose down || true
              docker-compose build --no-cache
              docker-compose up -d
              echo '‚úÖ FULL_RESTART completed'
              ;;
            'APP_ONLY')
              echo 'üöÄ Executing APP_ONLY: Rebuilding app container...'
              docker-compose stop voxpersona || true
              docker-compose build voxpersona
              docker-compose up -d voxpersona
              echo '‚úÖ APP_ONLY completed'
              ;;
            'NO_RESTART')
              echo 'üìù Executing NO_RESTART: Files synced, no container restart needed'
              echo '‚úÖ NO_RESTART completed'
              ;;
          esac
        "
    
    - name: Health checks and verification
      id: health_check
      env:
        DEPLOY_TYPE: ${{ steps.deployment_analysis.outputs.deployment_type }}
      run: |
        if [ "$DEPLOY_TYPE" != "NO_RESTART" ]; then
          echo "üè• Running health checks..."
          
          # Wait for containers to stabilize
          sleep 15
          
          # Check container status
          ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
            cd ${{ env.APP_PATH }}
            
            echo 'üìä Container status:'
            docker-compose ps
            
            # Check if voxpersona container is running
            CONTAINER_STATUS=\$(docker ps --filter 'name=voxpersona_app' --format '{{.Status}}')
            if [[ \$CONTAINER_STATUS == *'Up'* ]]; then
              echo '‚úÖ VoxPersona container is running'
            else
              echo '‚ùå VoxPersona container failed to start'
              docker-compose logs --tail=50 voxpersona
              exit 1
            fi
            
            # Additional health checks for full restart
            if [ '$DEPLOY_TYPE' = 'FULL_RESTART' ]; then
              POSTGRES_STATUS=\$(docker ps --filter 'name=voxpersona_postgres' --format '{{.Status}}')
              if [[ \$POSTGRES_STATUS == *'Up'* ]]; then
                echo '‚úÖ PostgreSQL container is running'
              else
                echo '‚ùå PostgreSQL container failed to start'
                docker-compose logs --tail=50 postgres
                exit 1
              fi
            fi
            
            # Test application configuration loading
            timeout 30 docker exec voxpersona_app python -c 'import src.config; print(\"Configuration loaded successfully\")' || {
              echo '‚ùå Application configuration test failed'
              docker-compose logs --tail=50 voxpersona
              exit 1
            }
            
            echo '‚úÖ All health checks passed'
          "
        else
          echo "‚è≠Ô∏è  Skipping health checks for NO_RESTART deployment"
        fi
    
    - name: Calculate deployment metrics
      id: metrics
      env:
        DEPLOY_START: ${{ steps.deployment_state.outputs.deploy_start }}
        DEPLOY_TYPE: ${{ steps.deployment_analysis.outputs.deployment_type }}
        FILES_CHANGED: ${{ steps.deployment_analysis.outputs.changed_files_count }}
        OLD_COMMIT: ${{ steps.deployment_state.outputs.old_commit }}
        NEW_COMMIT: ${{ steps.deployment_state.outputs.new_commit }}
      run: |
        DEPLOY_END=$(date +%s)
        DURATION=$((DEPLOY_END - DEPLOY_START))
        echo "duration=$DURATION" >> $GITHUB_OUTPUT
        
        echo "üìä Deployment Metrics:"
        echo "  - Type: $DEPLOY_TYPE"
        echo "  - Duration: ${DURATION}s"
        echo "  - Files changed: $FILES_CHANGED"
        echo "  - Commit: $OLD_COMMIT ‚Üí $NEW_COMMIT"
    
    - name: Log deployment success
      env:
        DEPLOY_TYPE: ${{ steps.deployment_analysis.outputs.deployment_type }}
        OLD_COMMIT: ${{ steps.deployment_state.outputs.old_commit }}
        NEW_COMMIT: ${{ steps.deployment_state.outputs.new_commit }}
        DURATION: ${{ steps.metrics.outputs.duration }}
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
      run: |
        echo "‚úÖ Deployment completed successfully!"
        
        # Log to server
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
          echo '$(date -Iseconds) [DEPLOY] $DEPLOY_TYPE: $OLD_COMMIT ‚Üí $NEW_COMMIT (${DURATION}s)' >> ${{ env.APP_PATH }}/deployment.log
        "
        
        echo "üéâ VoxPersona deployment completed:"
        echo "  ‚ú® Type: $DEPLOY_TYPE"
        echo "  ‚è±Ô∏è  Duration: $DURATION seconds"
        echo "  üìù Commit: $COMMIT_MESSAGE"
    
    - name: Rollback on failure
      if: failure()
      env:
        OLD_COMMIT: ${{ steps.deployment_state.outputs.old_commit }}
        NEW_COMMIT: ${{ steps.deployment_state.outputs.new_commit }}
      run: |
        echo "üö® Deployment failed, initiating rollback..."
        
        if [ "$OLD_COMMIT" != "none" ]; then
          ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
            cd ${{ env.PROJECT_PATH }}
            echo 'üîÑ Rolling back to previous commit: $OLD_COMMIT'
            git reset --hard $OLD_COMMIT
            
            # Re-sync files
            rsync -av --delete --exclude='.git' ${{ env.PROJECT_PATH }}/ ${{ env.APP_PATH }}/
            
            # Restart application
            cd ${{ env.APP_PATH }}
            docker-compose stop voxpersona || true
            docker-compose up -d voxpersona
            
            echo '‚úÖ Rollback completed'
          "
        else
          echo "‚ö†Ô∏è  No previous commit to rollback to (initial deployment)"
        fi
        
        # Log failure
        ssh ${{ env.SSH_OPTIONS }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "
          echo '$(date -Iseconds) [DEPLOY-FAILED] Rollback executed: $NEW_COMMIT ‚Üí $OLD_COMMIT' >> ${{ env.APP_PATH }}/deployment.log
        " || true
    
    - name: Notify on failure
      if: failure()
      env:
        TARGET_COMMIT: ${{ github.sha }}
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        DEPLOY_TYPE: ${{ steps.deployment_analysis.outputs.deployment_type }}
      run: |
        echo "üí• Deployment Failed Summary:"
        echo "  üéØ Target commit: $TARGET_COMMIT"
        echo "  üìù Commit message: $COMMIT_MESSAGE"
        echo "  üîÑ Deployment type: $DEPLOY_TYPE"
        echo "  ‚ö†Ô∏è  Check deployment logs on server: ${{ env.APP_PATH }}/deployment.log"